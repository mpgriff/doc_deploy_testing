{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to anemone Would you like to run transient electromagnetic simulations in python like this: dbdt = fwr(resistivity, thickness) With a few lines of setup particular to your instrumentation, it can be that easy. Intro Anemone is an open source electromagnetics simulator for 1-dimensional earth models. Anemone is built with pytorch , allowing for highly-parallel forward simulations leveraging GPUs. A priority for anemone is flexibility and readability. As with many other 1d EM codes, Ward and Hohmann 1988 is an indispensable reference. Where relevant, references to the W&H are included in the doc-strings of functions. The same is true for equations from other papers listed below. Key References Stanley H. Ward and Gerald W. Hohmann, (1988), \"4. Electromagnetic Theory for Geophysical Applications,\" Investigations in Geophysics : 130-311. https://doi.org/10.1190/1.9781560802631.ch4 Christensen, N.B. (1990), Optimized fast hankel transform filters. Geophysical Prospecting, 38: 545-568. https://doi.org/10.1111/j.1365-2478.1990.tb01861.x Johansen, H.K. and S\u00f8rensen, K. (1979), Fast Hankel Transforms. Geophysical Prospecting, 27: 876-901. https://doi.org/10.1111/j.1365-2478.1979.tb01005.x D. E. Boerner and G. F. West, (1984), Efficient calculation of the electromagnetic fields of an extended source. GEOPHYSICS 49: 2057-2060. https://doi.org/10.1190/1.1441618 Stehfest, H. (1970), Algorithm 368 Numerical inversion of Laplace transforms. Association for Computing Machinery (ACM), https://doi.org/10.1145/361953.361969","title":"Home"},{"location":"index.html#welcome-to-anemone","text":"Would you like to run transient electromagnetic simulations in python like this: dbdt = fwr(resistivity, thickness) With a few lines of setup particular to your instrumentation, it can be that easy.","title":"Welcome to anemone"},{"location":"index.html#intro","text":"Anemone is an open source electromagnetics simulator for 1-dimensional earth models. Anemone is built with pytorch , allowing for highly-parallel forward simulations leveraging GPUs. A priority for anemone is flexibility and readability. As with many other 1d EM codes, Ward and Hohmann 1988 is an indispensable reference. Where relevant, references to the W&H are included in the doc-strings of functions. The same is true for equations from other papers listed below.","title":"Intro"},{"location":"index.html#key-references","text":"Stanley H. Ward and Gerald W. Hohmann, (1988), \"4. Electromagnetic Theory for Geophysical Applications,\" Investigations in Geophysics : 130-311. https://doi.org/10.1190/1.9781560802631.ch4 Christensen, N.B. (1990), Optimized fast hankel transform filters. Geophysical Prospecting, 38: 545-568. https://doi.org/10.1111/j.1365-2478.1990.tb01861.x Johansen, H.K. and S\u00f8rensen, K. (1979), Fast Hankel Transforms. Geophysical Prospecting, 27: 876-901. https://doi.org/10.1111/j.1365-2478.1979.tb01005.x D. E. Boerner and G. F. West, (1984), Efficient calculation of the electromagnetic fields of an extended source. GEOPHYSICS 49: 2057-2060. https://doi.org/10.1190/1.1441618 Stehfest, H. (1970), Algorithm 368 Numerical inversion of Laplace transforms. Association for Computing Machinery (ACM), https://doi.org/10.1145/361953.361969","title":"Key References"},{"location":"project_layout.html","text":"The structure of anemone Anemone consists of four modules. experiment - objects representing experiment configuration parameters like transmit loop geometry, transmitter waveform, receiver filters, etc. forwards - where everything comes together. transforms - operators for the numerical computation of Hankel transforms, Fourier transforms and Inverse Laplace transforms. physics - base routines like reflection coefficients, wave numbers, etc. We will describe each of these modules here. Experiment A module containing various python objects representing experimental setup parameters. The Loop object contains the setup of the transmitter loop. For example, a 3m x 3m transmit loop can be instantiated with the call: tx = Loop.square(3) Similarly, the Receiver object sits in this module. Forwards The forward module contains all the forward operators. Transforms This module contains objects that will perform transforms on functions. Hankel transform Fourier transform inverse Fourier transform inverse Laplace transform Cubic spline If a tensor of more than one dimension results from the function to be transformed, the transform is performed along the last axis in the tensor. A test of the inverse Laplace transform gives a barebones example: from anemone.transforms import invLaplace def f(t): return 1./torch.sqrt(torch.pi*t) def laplace_of_f(s): return 1./torch.sqrt(s) Here is a function with its associated Laplace transform. We can obtain a numerically evaluated \\(f(t)\\) based on its Laplace transform alone using the Gaver-Stehfest method: t = torch.logspace(-7, 2, 101, dtype=torch.float64) numerical_f = invLaplace(laplace_of_f, n_coefficients=16) y1 = numerical_f(t) y2 = f(t) The building of the invLaplace returns a numerical version of the function that computes time-domain values based on evaluations of the Laplace function provided. Just for fun, here is the comparison of the analytic and numerically derived results from the example: Cubic spline is included in the module as in can provide a robust numerical integration routine. Physics This is pretty deep in the weeds. The physics itself make reference to Ward & Hohmann 1988 including the equation and page numbers. An important part of the physic module design is that functions are agnostic to the input array dimensionality. In this manner, functions closely resemble their mathematical formation. However, this means the dimensionality of all the input arrays must be compatible to begin with. Throughout the package, we use pytorch's (orignally numpy's ?) array broadcasting to accomplish this. The peak of the physics module is a the functions the compute the reflection coefficients for transverse electric and transverse magnetic waves. These have the function signature rte = refl_transverse_electric(sigma, thickness, omega, wave_length) The order of the arguments, matches the necessary order of the dimensions. so for a 10 layer sigma, 9 thicknesses, 101 frequencies, and 301 wave lengths, the dimensions will need to be tensor dimensions sigma (10, 1, 1) thick (9, 1, 1) omega (1, 101, 1) wave_length (1, 1, 301) return value: rte (1, 101, 301) This is necessary in order for the tensor to multiply and add with one another. Pytorch has a very nice notation to accomplish this. If all the tensors are 1 dimensional a function call can look like this: rte = refl_transverse_electric(sigma[:,None,None], thick[:,None,None], omega[None, :,None], wave_length[None, None, :]) This will return the reflection coefficients at the surface with a dimensionality of (1, 101, 301). In this manner, all the arrays are broadcast to the necessary dimensions. If any of the arrays are floats, no broadcasting is needed. References Stanley H. Ward and Gerald W. Hohmann, (1988), \"4. Electromagnetic Theory for Geophysical Applications,\" Investigations in Geophysics : 130-311. https://doi.org/10.1190/1.9781560802631.ch4 Christensen, N.B. (1990), Optimized fast hankel transform filters. Geophysical Prospecting, 38: 545-568. https://doi.org/10.1111/j.1365-2478.1990.tb01861.x Johansen, H.K. and S\u00f8rensen, K. (1979), Fast Hankel Transforms. Geophysical Prospecting, 27: 876-901. https://doi.org/10.1111/j.1365-2478.1979.tb01005.x Stehfest, H. (1970), Algorithm 368 Numerical inversion of Laplace transforms. Association for Computing Machinery (ACM), https://doi.org/10.1145/361953.361969","title":"Project Layout"},{"location":"project_layout.html#the-structure-of-anemone","text":"Anemone consists of four modules. experiment - objects representing experiment configuration parameters like transmit loop geometry, transmitter waveform, receiver filters, etc. forwards - where everything comes together. transforms - operators for the numerical computation of Hankel transforms, Fourier transforms and Inverse Laplace transforms. physics - base routines like reflection coefficients, wave numbers, etc. We will describe each of these modules here.","title":"The structure of anemone"},{"location":"project_layout.html#experiment","text":"A module containing various python objects representing experimental setup parameters. The Loop object contains the setup of the transmitter loop. For example, a 3m x 3m transmit loop can be instantiated with the call: tx = Loop.square(3) Similarly, the Receiver object sits in this module.","title":"Experiment"},{"location":"project_layout.html#forwards","text":"The forward module contains all the forward operators.","title":"Forwards"},{"location":"project_layout.html#transforms","text":"This module contains objects that will perform transforms on functions. Hankel transform Fourier transform inverse Fourier transform inverse Laplace transform Cubic spline If a tensor of more than one dimension results from the function to be transformed, the transform is performed along the last axis in the tensor. A test of the inverse Laplace transform gives a barebones example: from anemone.transforms import invLaplace def f(t): return 1./torch.sqrt(torch.pi*t) def laplace_of_f(s): return 1./torch.sqrt(s) Here is a function with its associated Laplace transform. We can obtain a numerically evaluated \\(f(t)\\) based on its Laplace transform alone using the Gaver-Stehfest method: t = torch.logspace(-7, 2, 101, dtype=torch.float64) numerical_f = invLaplace(laplace_of_f, n_coefficients=16) y1 = numerical_f(t) y2 = f(t) The building of the invLaplace returns a numerical version of the function that computes time-domain values based on evaluations of the Laplace function provided. Just for fun, here is the comparison of the analytic and numerically derived results from the example: Cubic spline is included in the module as in can provide a robust numerical integration routine.","title":"Transforms"},{"location":"project_layout.html#physics","text":"This is pretty deep in the weeds. The physics itself make reference to Ward & Hohmann 1988 including the equation and page numbers. An important part of the physic module design is that functions are agnostic to the input array dimensionality. In this manner, functions closely resemble their mathematical formation. However, this means the dimensionality of all the input arrays must be compatible to begin with. Throughout the package, we use pytorch's (orignally numpy's ?) array broadcasting to accomplish this. The peak of the physics module is a the functions the compute the reflection coefficients for transverse electric and transverse magnetic waves. These have the function signature rte = refl_transverse_electric(sigma, thickness, omega, wave_length) The order of the arguments, matches the necessary order of the dimensions. so for a 10 layer sigma, 9 thicknesses, 101 frequencies, and 301 wave lengths, the dimensions will need to be tensor dimensions sigma (10, 1, 1) thick (9, 1, 1) omega (1, 101, 1) wave_length (1, 1, 301) return value: rte (1, 101, 301) This is necessary in order for the tensor to multiply and add with one another. Pytorch has a very nice notation to accomplish this. If all the tensors are 1 dimensional a function call can look like this: rte = refl_transverse_electric(sigma[:,None,None], thick[:,None,None], omega[None, :,None], wave_length[None, None, :]) This will return the reflection coefficients at the surface with a dimensionality of (1, 101, 301). In this manner, all the arrays are broadcast to the necessary dimensions. If any of the arrays are floats, no broadcasting is needed.","title":"Physics"},{"location":"project_layout.html#references","text":"Stanley H. Ward and Gerald W. Hohmann, (1988), \"4. Electromagnetic Theory for Geophysical Applications,\" Investigations in Geophysics : 130-311. https://doi.org/10.1190/1.9781560802631.ch4 Christensen, N.B. (1990), Optimized fast hankel transform filters. Geophysical Prospecting, 38: 545-568. https://doi.org/10.1111/j.1365-2478.1990.tb01861.x Johansen, H.K. and S\u00f8rensen, K. (1979), Fast Hankel Transforms. Geophysical Prospecting, 27: 876-901. https://doi.org/10.1111/j.1365-2478.1979.tb01005.x Stehfest, H. (1970), Algorithm 368 Numerical inversion of Laplace transforms. Association for Computing Machinery (ACM), https://doi.org/10.1145/361953.361969","title":"References"},{"location":"quick_start.html","text":"quick start Installation Pre-requisites before installing anemone, the following pre-requisites are needed: python, 3.9 or newer. pytorch We recommend installing pytorch from their page: https://pytorch.org/get-started/locally/ Installation navigate into the anemone folder from the console and enter the following command: pip install -e . Usage The following is a bare bones example to compute a TEM forward. A detailed walk-through of this example is provided on the usage page . from anemone.forwards import Forward from anemone.experiment import Loop, Receiver, Waveform import torch tx = Loop.square(40) rx = Receiver() # by default located at x,y,z=(0,0,0) wv = Waveform.example()# trapezoidal example t = torch.logspace(-5, -3, 32) fwr = Forward(tx, rx, t, waveform=wv) rho = torch.tensor([40., 80., 40.]) thick = torch.tensor([20., 30.]) dbdt = fwr(rho, thick)","title":"Quick Start"},{"location":"quick_start.html#quick-start","text":"","title":"quick start"},{"location":"quick_start.html#installation","text":"","title":"Installation"},{"location":"quick_start.html#pre-requisites","text":"before installing anemone, the following pre-requisites are needed: python, 3.9 or newer. pytorch We recommend installing pytorch from their page: https://pytorch.org/get-started/locally/","title":"Pre-requisites"},{"location":"quick_start.html#installation_1","text":"navigate into the anemone folder from the console and enter the following command: pip install -e .","title":"Installation"},{"location":"quick_start.html#usage","text":"The following is a bare bones example to compute a TEM forward. A detailed walk-through of this example is provided on the usage page . from anemone.forwards import Forward from anemone.experiment import Loop, Receiver, Waveform import torch tx = Loop.square(40) rx = Receiver() # by default located at x,y,z=(0,0,0) wv = Waveform.example()# trapezoidal example t = torch.logspace(-5, -3, 32) fwr = Forward(tx, rx, t, waveform=wv) rho = torch.tensor([40., 80., 40.]) thick = torch.tensor([20., 30.]) dbdt = fwr(rho, thick)","title":"Usage"},{"location":"usage.html","text":"Example 1 (quick-start) Let's walk-through the example we saw in the quick start . The imports from anemone.experiment import Loop, Receiver, Waveform from anemone.forwards import Forward import torch The main user configurable bits are included in the anemone.experiment module. The forward module contains operators that take the users defined configuration and returns a function that computes \\(dB/dt\\) based on resistivity and thickness. torch is required for tensors (or arrays), for example the set of times for which \\(dB/dt\\) is evaluated, or the resistivity values in the 1d earth. The configuration tx = Loop.square(40) rx = Receiver() # by default located at x,y,z=(0,0,0) wv = Waveform.example()# trapezoidal example t = torch.logspace(-5, -3, 32) fwr = Forward(tx, rx, t, waveform=wv) In this example, we have defined the following TEM system: - a 40m x 40m transmit loop - a unit dipole receiver placed at the origin - trapezoidal example waveform - set of times at which \\(dB/dt\\) is evaluated. The forward operator takes these configuration parameters and return the function for follow-up simulations of the \\(dB/dt\\) response. Running a forward Now, running the forward is relatively simple: rho = torch.tensor([40., 80., 40.]) thick = torch.tensor([20., 30.]) dbdt = fwr(rho, thick) We define our resistivity values in the layers and the associated thicknesses (last layer extends to infinity) and we can pass these tensors to the forward function to get the response. We've used 3 layers in the example, but an arbitrary number can used. Running multiple forwards Instead of the single \\(dB/dt\\) response, multiple can be obtained in one function call. The important thing is that the layers are indexed along the 0-th dimension: rho = torch.ones((3,10))*40 rho[1, :] = torch.linspace(30, 80, 10) # sweep the middle layer thick = torch.ones((2,10))*20. thick[1,:] = 30 dbdts = fwr(rho, thick)","title":"Usage"},{"location":"usage.html#example-1-quick-start","text":"Let's walk-through the example we saw in the quick start .","title":"Example 1 (quick-start)"},{"location":"usage.html#the-imports","text":"from anemone.experiment import Loop, Receiver, Waveform from anemone.forwards import Forward import torch The main user configurable bits are included in the anemone.experiment module. The forward module contains operators that take the users defined configuration and returns a function that computes \\(dB/dt\\) based on resistivity and thickness. torch is required for tensors (or arrays), for example the set of times for which \\(dB/dt\\) is evaluated, or the resistivity values in the 1d earth.","title":"The imports"},{"location":"usage.html#the-configuration","text":"tx = Loop.square(40) rx = Receiver() # by default located at x,y,z=(0,0,0) wv = Waveform.example()# trapezoidal example t = torch.logspace(-5, -3, 32) fwr = Forward(tx, rx, t, waveform=wv) In this example, we have defined the following TEM system: - a 40m x 40m transmit loop - a unit dipole receiver placed at the origin - trapezoidal example waveform - set of times at which \\(dB/dt\\) is evaluated. The forward operator takes these configuration parameters and return the function for follow-up simulations of the \\(dB/dt\\) response.","title":"The configuration"},{"location":"usage.html#running-a-forward","text":"Now, running the forward is relatively simple: rho = torch.tensor([40., 80., 40.]) thick = torch.tensor([20., 30.]) dbdt = fwr(rho, thick) We define our resistivity values in the layers and the associated thicknesses (last layer extends to infinity) and we can pass these tensors to the forward function to get the response. We've used 3 layers in the example, but an arbitrary number can used.","title":"Running a forward"},{"location":"usage.html#running-multiple-forwards","text":"Instead of the single \\(dB/dt\\) response, multiple can be obtained in one function call. The important thing is that the layers are indexed along the 0-th dimension: rho = torch.ones((3,10))*40 rho[1, :] = torch.linspace(30, 80, 10) # sweep the middle layer thick = torch.ones((2,10))*20. thick[1,:] = 30 dbdts = fwr(rho, thick)","title":"Running multiple forwards"}]}